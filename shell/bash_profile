#!/usr/bin/env bash
[ -n "$PS1" ] || return

export DOTFILES_DIR="${HOME}/.dotfiles"
source "${DOTFILES_DIR}/lib/colors"

##############################################################################
# Environment options
##############################################################################

# http://stackoverflow.com/questions/370047/what-is-the-most-elegant-way-to-remove-a-path-from-the-path-variable-in-bash
path_append ()  { path_remove $1; [[ -d "$1" ]] && export PATH="$PATH:$1"; }
path_prepend () { path_remove $1; [[ -d "$1" ]] && export PATH="$1:$PATH"; }
path_remove ()  { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=: '$0 != "'$1'"' | sed 's/:$//'`; }

path_prepend "/usr/local/bin"
# path_prepend "$(brew --prefix coreutils)/libexec/gnubin"
path_append "${DOTFILES_DIR}/bin"
path_append "/usr/texbin"

# Make vim the default editor
export EDITOR="vim"

# Prefer US English and use UTF-8
export LANG="en_US"
export LC_ALL="en_US.UTF-8"

# Highlight section titles in manual pages
export LESS_TERMCAP_md="${yellow}";

# Don’t clear the screen after quitting a manual page
export MANPAGER="less -X"

# Prevent less from clearing the screen while still showing colors.
export LESS=-XR

# Always enable colored `grep` output
export GREP_OPTIONS="--color=auto"

# Link Homebrew casks in `/Applications` rather than `~/Applications`
export HOMEBREW_CASK_OPTS="--appdir=/Applications";

# Case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob

# Autocorrect typos in path names when using `cd`
shopt -s cdspell

# Bash 4 recursive cd, e.g. `**/qux` will enter `./foo/bar/baz/qux`
shopt -s autocd 2> /dev/null;

# Bash 4 recursive globbing, e.g. `echo **/*.txt`
shopt -s globstar 2> /dev/null;

# Check the window size after each command and, if necessary, update the values
# of LINES and COLUMNS.
shopt -s checkwinsize

# Raise limit for open files and processes
ulimit -S -n 1024

# Export PhantomJS bin location
type -P brew &>/dev/null && export PHANTOMJS_BIN="$(brew --prefix)/bin/phantomjs"




##############################################################################
# History
##############################################################################

# Larger bash history (allow 32³ entries; default is 500)
export HISTSIZE=32768
export HISTFILESIZE=$HISTSIZE
export HISTCONTROL="ignorespace:erasedups"

# Make some commands not show up in history
# TODO: man, cd .., ll, la, lsd, which *
export HISTIGNORE="ls:cd:cd -:pwd:exit:date:* --help:&:[fb]g"

# Append to the Bash history file, rather than overwriting it
shopt -s histappend

# Remove short dir from Terminal.app title and write every command to history
PROMPT_COMMAND=${PROMPT_COMMAND//update_terminal_cwd;/}
PROMPT_COMMAND=${PROMPT_COMMAND//history -a;/}
export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"




##############################################################################
# Aliases
##############################################################################

# Allow aliases to be with sudo
alias sudo="sudo "

# cd
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias -- -="cd -"
alias bd=". bd -s"

# Shortcuts
alias s="cd ~/Source"
alias g="git"

# Detect which `ls` flavor is in use
if ls --color > /dev/null 2>&1; then # GNU `ls`
    alias ls="command ls --color"
else # OS X `ls`
    alias ls="command ls -G"
fi

# ls color map for OS X and GNU ls
function set_ls_colors() {

    # man ls | grep "LSCOLORS" -- OS X
    local -a osx=(
        'ex'  # blue - directory
        'gx'  # cyan - symbolic link
        'fx'  # magenta - socket
        'fx'  # magenta - pipe
        'cx'  # green - executable
        'fx'  # magenta - block special
        'fx '  # magenta - character special
        'cx'  # green - executable with setuid bit set
        'cx'  # green - executable with setgid bit set
        'ex'  # blue - directory writable to others, with sticky bit
        'ex'  # blue - directory writable to others, without sticky bit
    )
    local a="${osx[*]}"
    export LSCOLORS="${a// /}"

    # http://www.bigsoft.co.uk/blog/index.php/2008/04/11/configuring-ls_colors
    local -a gnu=(
        'no=00'         # default
        'fi=00'         # file

        # directory - blue
        'di=01;34'

        # executable - green
        'ex=01;32'

        # link - cyan (similar to green since links are usually to exe)
        'ln=01;36'

        # system files - magenta
        'pi=35'         # fifo
        'so=35'         # socket
        'do=35'         # door
        'bd=35'         # block file
        'cd=35'         # character file

        # bad links - red
        'or=31'         # orphan link
        'mi=31'         # missing file


        # binary files - violet
        '*.tar=95'   # Zips
        '*.tgz=95'   #
        '*.arj=95'   #
        '*.taz=95'   #
        '*.lzh=95'   #
        '*.zip=95'   #
        '*.z=95'     #
        '*.Z=95'     #
        '*.gz=95'    #
        '*.bz2=95'   #
        '*.deb=95'   #
        '*.rpm=95'   #
        '*.jar=95'   #
        '*.jpg=95'   # Images
        '*.jpeg=95'  #
        '*.gif=95'   #
        '*.bmp=95'   #
        '*.pbm=95'   #
        '*.pgm=95'   #
        '*.ppm=95'   #
        '*.tga=95'   #
        '*.xbm=95'   #
        '*.xpm=95'   #
        '*.tif=95'   #
        '*.tiff=95'  #
        '*.png=95'   #
        '*.mov=95'   #
        '*.mpg=95'   #
        '*.mpeg=95'  #
        '*.avi=95'   #
        '*.fli=95'   #
        '*.gl=95'    #
        '*.dl=95'    #
        '*.xcf=95'   #
        '*.xwd=95'   #
        '*.ogg=95'   #
        '*.mp3=95'   #
        '*.wav=95'   #
    )
    local b="${gnu[*]}"
    export LS_COLORS="${b// /:}"
}
set_ls_colors
unset set_ls_colors

alias la="ls -AF"     # all
alias ll="ls -lF"     # long
alias lla="ls -lAF"   # all, long
alias lsd="ls -d */"  # dir only
alias l="ls -ogF"     # long, no user, no group
alias lt="ls -toF"    # by last modified, long, no user, no group
alias lz="ls -lrSog"  # by size, lon, no user, no group
alias dir="tree --dirsfirst -ChFpDaL 1"

# Reload the shell (i.e. invoke as a login shell)
alias reload="exec $SHELL -l"

# Concatenate and print content of files (add line numbers)
alias lines="cat -n"

## IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias ipl="ipconfig getifaddr en0"
alias ips="ifconfig -a | grep -o 'inet6\? \(addr:\)\?\s\?\(\(\([0-9]\+\.\)\{3\}[0-9]\+\)\|[a-fA-F0-9:]\+\)' | awk '{ sub(/inet6? (addr:)? ?/, \"\"); print }'"

# Copy my public key to the pasteboard
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | printf '=> Public key copied to pasteboard.\n'"

## Request using GET, POST, etc. method credit:@janmoesen
for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
    alias "$method"="lwp-request -m '$method'"
done

# Show/hide hidden files in Finder
alias show="defaults write com.apple.finder AppleShowAllFiles -bool true && killall Finder"
alias hide="defaults write com.apple.finder AppleShowAllFiles -bool false && killall Finder"

# Hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"

## Speed Test
alias speedtest="wget -O /dev/null http://speedtest.wdc01.softlayer.com/downloads/test10.zip"

# Stopwatch
alias timer='echo "Timer started. Stop with Ctrl-D." && date && time cat && date'

# View HTTP traffic
alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""

# Canonical hex dump; some systems have this symlinked
command -v hd > /dev/null || alias hd="hexdump -C"

# OS X has no `md5sum`, so use `md5` as a fallback
command -v md5sum > /dev/null || alias md5sum="md5"

# OS X has no `sha1sum`, so use `shasum` as a fallback
command -v sha1sum > /dev/null || alias sha1sum="shasum"

# JavaScriptCore REPL
jscbin="/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc";
[ -e "${jscbin}" ] && alias jsc="${jscbin}";
unset jscbin;

# URL-encode strings
alias urlencode='python -c "import sys, urllib as ul; print ul.quote_plus(sys.argv[1]);"'

# Merge PDF files
# Usage: `mergepdf -o output.pdf input{1,2,3}.pdf`
alias mergepdf='/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py'

# Disable Spotlight
alias spotoff="sudo mdutil -a -i off"
# Enable Spotlight
alias spoton="sudo mdutil -a -i on"

# PlistBuddy alias, because sometimes `defaults` just doesn’t cut it
alias plistbuddy="/usr/libexec/PlistBuddy"

# Ring the terminal bell, and put a badge on Terminal.app’s Dock icon
# (useful when executing time-consuming commands)
alias badge="tput bel"

# Intuitive map function
# For example, to list all directories that contain a certain file:
# find . -name .gitattributes | map dirname
alias map="xargs -n1"

# Aliasing eachdir like this allows you to use aliases/functions as commands.
alias eachdir=". eachdir"



##############################################################################
# Functions
##############################################################################

# Create a new directory and enter it
mkd() { mkdir -p "$@" && cd "$@"; }

# Fuzzy find file/dir - credit:@webpro
ff()  { find . -type f -name "${1}";  }
fff() { find . -type f -name "*${1}*";}
fd()  { find . -type d -name "${1}";  }
fdf() { find . -type d -name "*${1}*";}

# Show disk usage of current folder, or list with depth - credit:@webpro
duf() {
    du -d ${1} -c | sort -r -n | awk '{split("K M G",v); s=1; while($1>1024){$1/=1024; s++} print int($1)v[s]"\t"$2}'
}

# Open man page as PDF - credit:@webpro
manpdf() {
    man -t "${1}" | open -f -a /Applications/Preview.app/
}

# Show line, optionally show surrounding lines - credit:@webpro
line() {
    local line_number=$1
    local lines_around=${2:-0}
    sed -n "`expr $line_number - $lines_around`,`expr $line_number + $lines_around`p"
}

# Extract many types of compress files
# credit: http://nparikh.org/notes/zshrc.txt
extract() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)  tar -jxvf $1                        ;;
            *.tar.gz)   tar -zxvf $1                        ;;
            *.bz2)      bunzip2 $1                          ;;
            *.dmg)      hdiutil mount $1                    ;;
            *.gz)       gunzip $1                           ;;
            *.tar)      tar -xvf $1                         ;;
            *.tbz2)     tar -jxvf $1                        ;;
            *.tgz)      tar -zxvf $1                        ;;
            *.zip)      unzip $1                            ;;
            *.ZIP)      unzip $1                            ;;
            *.pax)      cat $1 | pax -r                     ;;
            *.pax.Z)    uncompress $1 --stdout | pax -r     ;;
            *.Z)        uncompress $1                       ;;
            *)          echo "'$1' cannot be extracted/mounted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file to extract"
    fi
}

# Check if resource is served compressed - credit:@webpro
check_compression() {
    curl --write-out 'Size (uncompressed) = %{size_download}\n' --silent --output /dev/null $1
    curl --header 'Accept-Encoding: gzip,deflate,compress' --write-out 'Size (compressed) =   %{size_download}\n' --silent --output /dev/null $1
    curl --head --header 'Accept-Encoding: gzip,deflate' --silent $1 | grep -i "cache\|content\|vary\|expires"
}

# Get gzipped file size - credit:@webpro
gz() {
    local origsize=$(wc -c < "$1")
    local gzipsize=$(gzip -c "$1" | wc -c)
    local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
    local saved=$(echo "($origsize - $gzipsize) * 100/ $origsize" | bc -l)
    printf "orig: %d bytes\ngzip: %d bytes\nsave: %2.0f%% (%2.0f%%)\n" "$origsize" "$gzipsize" "$saved" "$ratio"
}

# Create a data URI from a file and copy it to the pasteboard - credit:@necolas
datauri() {
    local mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    printf "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')" | pbcopy | printf "=> data URI copied to pasteboard.\n"
}

# Start an HTTP server from a directory, optionally specifying the port - credit:@necolas
pyserver() {
    # Get port (if specified)
    local port="${1:-8000}"

    # Open in the browser
    open "http://localhost:${port}/"

    # Redefining the default content-type to text/plain instead of the default
    # application/octet-stream allows "unknown" files to be viewable in-browser
    # as text instead of being downloaded.
    #
    # Unfortunately, "python -m SimpleHTTPServer" doesn't allow you to redefine
    # the default content-type, but the SimpleHTTPServer module can be executed
    # manually with just a few lines of code.
    python -c $'import SimpleHTTPServer;\nSimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map[""] = "text/plain";\nSimpleHTTPServer.test();' "$port"
}

# TODO: merge this from @mathiasbynens with the above from @necolas
# # Start an HTTP server from a directory, optionally specifying the port
# function server() {
#     local port="${1:-8000}";
#     sleep 1 && open "http://localhost:${port}/" &
#     # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
#     # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
#     python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
# }

# Simple calculator - credit:@mathiasbynens
function calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript;
    else # pipe
        python -mjson.tool | pygmentize -l javascript;
    fi;
}

# TODO: adjudicate this from @gf3 with above function
# # Pretty print JSON
# cjson () {
#   local url=$(echo $1)
#   if [[ "http" == $url[0,4] ]] ; then
#     curl --silent $url | python -mjson.tool | pygmentize -O style=monokai -f console256 -g
#   else
#     cat $url | python -mjson.tool | pygmentize -O style=monokai -f console256 -g
#   fi
# }

# Run `dig` and display the most useful info
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}

# UTF-8-encode a string of Unicode symbols
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Get a character’s Unicode code point
function codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified.";
        return 1;
    fi;

    local domain="${1}";
    echo "Testing ${domain}…";
    echo ""; # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" 2>&1);

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_header, no_serial, no_version, \
            no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
            echo "Common Name:";
            echo ""; # newline
            echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
            echo ""; # newline
            echo "Subject Alternative Name(s):";
            echo ""; # newline
            echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
                | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
            return 0;
    else
        echo "ERROR: Certificate not found.";
        return 1;
    fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Image width
width () {
  echo $(sips -g pixelWidth $1 | grep -oE "[[:digit:]]{1,}$")
}

# Image height
height () {
  echo $(sips -g pixelHeight $1 | grep -oE "[[:digit:]]{1,}$")
}

# Set the terminal's title bar.
function titlebar() {
  echo -n $'\e]0;'"$*"$'\a'
}


##############################################################################
# Completion
##############################################################################

# Add tab completion for many Bash commands
if which brew > /dev/null && [ -f "$(brew --prefix)/etc/bash_completion" ]; then
    source "$(brew --prefix)/etc/bash_completion";
elif [ -f /etc/bash_completion ]; then
    source /etc/bash_completion;
fi;

# Enable tab completion for `g` by marking it as an alias for `git`
if type _git &> /dev/null && [ -f /usr/local/etc/bash_completion.d/git-completion.bash ]; then
    complete -o default -o nospace -F _git g;
fi;

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2)" scp sftp ssh

# Grunt
type -P grunt &>/dev/null && eval "$(grunt --completion=bash)"

# Add `killall` tab completion for common apps
complete -o "nospace" -W "Contacts Calendar Dock Finder Mail Safari iTunes SystemUIServer Terminal Twitter" killall;




##############################################################################
# Prompt
##############################################################################

# import git prompt if not already sourced by bash completiong above
if [ -z $(type -t __git_ps1) ]; then
    if which brew > /dev/null && [ -f "$(brew --prefix)/etc/bash_completion.d/git-prompt.sh" ]; then
        source $(brew --prefix)/etc/bash_completion.d/git-prompt.sh
    elif [ -f /usr/lib/git-core/git-sh-prompt ]; then
        source /usr/lib/git-core/git-sh-prompt
    fi
fi

GIT_PS1_SHOWDIRTYSTATE=true
GIT_PS1_SHOWSTASHSTATE=true
GIT_PS1_SHOWUNTRACKEDFILES=true
GIT_PS1_SHOWUPSTREAM="auto"
GIT_PS1_STATESEPARATOR=" $magenta"

# Tweak standard __git_ps1 output:
# - ensure space before upstream markers and color them
# - remove = upstream marker
# - replace markers
git_info() {
    __git_ps1 "%s" \
    | sed -e "s/\([<>]*\)$/ $yellow\1/" \
    | tr -d "=" \
    | tr "*%<>" "!?⇣⇡"
}

PS1="\[\033]2;\w\007\]"                     # window title to full working directory
PS1+="\[\033]1;\W\007\]"                    # tab title to short working directory
PS1+="\n"                                   # first line (info)
[[ "$SSH_TTY" ]] && PS1+="\[$orange\]\h "   #   only show host if connected via ssh
PS1+="\[$blue\]\w "                         #   working directory
PS1+="$green\$(git_info)"                   #   git branch / status
PS1+="\n"                                   # second line (prompt)
[[ $EUID == 0 ]] && PS1+="\[$red\]\u "      #   only show user if root
PS1+="\[$reset\]\\$ "                       # "smart" prompt char ($ or #)
export PS1
export PS2="\[${yellow}\]→ \[${reset}\]";




##############################################################################
# Cleanup
##############################################################################
unset path_append path_prepend path_remove
