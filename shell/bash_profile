#!/usr/bin/env bash
[ -n "$PS1" ] || return

export DOTFILES_DIR="${HOME}/.dotfiles"

##############################################################################
# Environment options
##############################################################################

# http://stackoverflow.com/questions/370047/what-is-the-most-elegant-way-to-remove-a-path-from-the-path-variable-in-bash
path_append ()  { path_remove $1; [[ -d "$1" ]] && export PATH="$PATH:$1"; }
path_prepend () { path_remove $1; [[ -d "$1" ]] && export PATH="$1:$PATH"; }
path_remove ()  { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=: '$0 != "'$1'"' | sed 's/:$//'`; }

path_prepend "/usr/local/bin"
path_append "${DOTFILES_DIR}/bin"
path_append "/usr/texbin"

# Make vim the default editor
export EDITOR="vim"

# Prefer US English and use UTF-8
export LANG="en_US"
export LC_ALL="en_US.UTF-8"

# Don’t clear the screen after quitting a manual page
export MANPAGER="less -X"

# Always enable colored `grep` output
export GREP_OPTIONS="--color=auto"

# Link Homebrew casks in `/Applications` rather than `~/Applications`
export HOMEBREW_CASK_OPTS="--appdir=/Applications";

# Case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob

# Autocorrect typos in path names when using `cd`
shopt -s cdspell

# Bash 4 recursive cd, e.g. `**/qux` will enter `./foo/bar/baz/qux`
shopt -s autocd 2> /dev/null;

# Bash 4 recursive globbing, e.g. `echo **/*.txt`
shopt -s globstar 2> /dev/null;

# Check the window size after each command and, if necessary, update the values
# of LINES and COLUMNS.
shopt -s checkwinsize

# Raise limit for open files and processes
ulimit -S -n 1024

# Export PhantomJS bin location
type -P brew &>/dev/null && export PHANTOMJS_BIN="$(brew --prefix)/bin/phantomjs"




##############################################################################
# History
##############################################################################

# Larger bash history (allow 32³ entries; default is 500)
export HISTSIZE=32768
export HISTFILESIZE=$HISTSIZE
export HISTCONTROL="ignorespace:erasedups"

# Make some commands not show up in history
# TODO: man, cd .., ll, la, lsd, which *
export HISTIGNORE="ls:cd:cd -:pwd:exit:date:* --help:&:[fb]g"

# Append to the Bash history file, rather than overwriting it
shopt -s histappend

# Remove short dir from Terminal.app title and write every command to history
PROMPT_COMMAND=${PROMPT_COMMAND//update_terminal_cwd;/}
PROMPT_COMMAND=${PROMPT_COMMAND//history -a;/}
export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"




##############################################################################
# Aliases
##############################################################################

# Allow aliases to be with sudo
alias sudo="sudo "

# cd
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias -- -="cd -"
alias bd=". bd -s"

# Shortcuts
alias s="cd ~/Source"
alias g="git"

# Detect which `ls` flavor is in use
if ls --color > /dev/null 2>&1; then # GNU `ls`
    alias ls="command ls --color"
else # OS X `ls`
    alias ls="command ls -G"
fi

# ls color map for OS X and GNU ls
function set_ls_colors() {

    # man ls | grep "LSCOLORS" -- OS X
    local -a osx=(
        'ex'  # blue - directory
        'gx'  # cyan - symbolic link
        'fx'  # magenta - socket
        'fx'  # magenta - pipe
        'cx'  # green - executable
        'fx'  # magenta - block special
        'fx '  # magenta - character special
        'cx'  # green - executable with setuid bit set
        'cx'  # green - executable with setgid bit set
        'ex'  # blue - directory writable to others, with sticky bit
        'ex'  # blue - directory writable to others, without sticky bit
    )
    local a="${osx[*]}"
    export LSCOLORS="${a// /}"

    # http://www.bigsoft.co.uk/blog/index.php/2008/04/11/configuring-ls_colors
    local -a gnu=(
        'no=00'         # default
        'fi=00'         # file

        # directory - blue
        'di=01;34'

        # executable - green
        'ex=01;32'

        # link - cyan (similar to green since links are usually to exe)
        'ln=01;36'

        # system files - magenta
        'pi=35'         # fifo
        'so=35'         # socket
        'do=35'         # door
        'bd=35'         # block file
        'cd=35'         # character file

        # bad links - red
        'or=31'         # orphan link
        'mi=31'         # missing file


        # binary files - violet
        '*.tar=95'   # Zips
        '*.tgz=95'   #
        '*.arj=95'   #
        '*.taz=95'   #
        '*.lzh=95'   #
        '*.zip=95'   #
        '*.z=95'     #
        '*.Z=95'     #
        '*.gz=95'    #
        '*.bz2=95'   #
        '*.deb=95'   #
        '*.rpm=95'   #
        '*.jar=95'   #
        '*.jpg=95'   # Images
        '*.jpeg=95'  #
        '*.gif=95'   #
        '*.bmp=95'   #
        '*.pbm=95'   #
        '*.pgm=95'   #
        '*.ppm=95'   #
        '*.tga=95'   #
        '*.xbm=95'   #
        '*.xpm=95'   #
        '*.tif=95'   #
        '*.tiff=95'  #
        '*.png=95'   #
        '*.mov=95'   #
        '*.mpg=95'   #
        '*.mpeg=95'  #
        '*.avi=95'   #
        '*.fli=95'   #
        '*.gl=95'    #
        '*.dl=95'    #
        '*.xcf=95'   #
        '*.xwd=95'   #
        '*.ogg=95'   #
        '*.mp3=95'   #
        '*.wav=95'   #
    )
    local b="${gnu[*]}"
    export LS_COLORS="${b// /:}"
}
set_ls_colors
unset set_ls_colors

alias la="ls -AF"     # all
alias ll="ls -lF"     # long
alias lla="ls -lAF"   # all, long
alias lsd='ls -d */'  # dir only
alias l="ls -ogF"     # long, no user, no group
alias lt="ls -toF"    # by last modified, long, no user, no group
alias lz="ls -lrSog"  # by size, lon, no user, no group

# Reload the shell (i.e. invoke as a login shell)
alias reload="exec $SHELL -l"

# Concatenate and print content of files (add line numbers)
alias lines="cat -n"

## IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias ipl="ipconfig getifaddr en0"

# Copy my public key to the pasteboard
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | printf '=> Public key copied to pasteboard.\n'"

## Request using GET, POST, etc. method
for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
    alias "$method"="lwp-request -m '$method'"
done

# Show/hide hidden files in Finder
alias showdotfiles="defaults write com.apple.finder AppleShowAllFiles -bool true && killall Finder"
alias hidedotfiles="defaults write com.apple.finder AppleShowAllFiles -bool false && killall Finder"

# Hide/show all desktop icons (useful when presenting)
alias showdeskicons="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"
alias hidedeskicons="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"

## Speed Test
alias speedtest="wget -O /dev/null http://speedtest.wdc01.softlayer.com/downloads/test10.zip"



##############################################################################
# Functions
##############################################################################

# Create a new directory and enter it
mk() { mkdir -p "$@" && cd "$@" }

# Fuzzy find file/dir - credit:@webpro
ff()  { find . -type f -name "${1}";  }
fff() { find . -type f -name "*${1}*";}
fd()  { find . -type d -name "${1}";  }
fdf() { find . -type d -name "*${1}*";}

# Show disk usage of current folder, or list with depth - credit:@webpro
duf() {
    du -d ${1} -c | sort -r -n | awk '{split("K M G",v); s=1; while($1>1024){$1/=1024; s++} print int($1)v[s]"\t"$2}'
}

# Open man page as PDF - credit:@webpro
manpdf() {
    man -t "${1}" | open -f -a /Applications/Preview.app/
}

# Show line, optionally show surrounding lines - credit:@webpro
line() {
    local line_number=$1
    local lines_around=${2:-0}
    sed -n "`expr $line_number - $lines_around`,`expr $line_number + $lines_around`p"
}

# Extract many types of compress files
# credit: http://nparikh.org/notes/zshrc.txt
extract() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)  tar -jxvf $1                        ;;
            *.tar.gz)   tar -zxvf $1                        ;;
            *.bz2)      bunzip2 $1                          ;;
            *.dmg)      hdiutil mount $1                    ;;
            *.gz)       gunzip $1                           ;;
            *.tar)      tar -xvf $1                         ;;
            *.tbz2)     tar -jxvf $1                        ;;
            *.tgz)      tar -zxvf $1                        ;;
            *.zip)      unzip $1                            ;;
            *.ZIP)      unzip $1                            ;;
            *.pax)      cat $1 | pax -r                     ;;
            *.pax.Z)    uncompress $1 --stdout | pax -r     ;;
            *.Z)        uncompress $1                       ;;
            *)          echo "'$1' cannot be extracted/mounted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file to extract"
    fi
}

# Check if resource is served compressed - credit:@webpro
check_compression() {
    curl --write-out 'Size (uncompressed) = %{size_download}\n' --silent --output /dev/null $1
    curl --header 'Accept-Encoding: gzip,deflate,compress' --write-out 'Size (compressed) =   %{size_download}\n' --silent --output /dev/null $1
    curl --head --header 'Accept-Encoding: gzip,deflate' --silent $1 | grep -i "cache\|content\|vary\|expires"
}

# Get gzipped file size - credit:@webpro
gz() {
    local origsize=$(wc -c < "$1")
    local gzipsize=$(gzip -c "$1" | wc -c)
    local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
    local saved=$(echo "($origsize - $gzipsize) * 100/ $origsize" | bc -l)
    printf "orig: %d bytes\ngzip: %d bytes\nsave: %2.0f%% (%2.0f%%)\n" "$origsize" "$gzipsize" "$saved" "$ratio"
}

# Create a data URI from a file and copy it to the pasteboard - credit:@necolas
datauri() {
    local mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    printf "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')" | pbcopy | printf "=> data URI copied to pasteboard.\n"
}

# Start an HTTP server from a directory, optionally specifying the port - credit:@necolas
pyserver() {
    # Get port (if specified)
    local port="${1:-8000}"

    # Open in the browser
    open "http://localhost:${port}/"

    # Redefining the default content-type to text/plain instead of the default
    # application/octet-stream allows "unknown" files to be viewable in-browser
    # as text instead of being downloaded.
    #
    # Unfortunately, "python -m SimpleHTTPServer" doesn't allow you to redefine
    # the default content-type, but the SimpleHTTPServer module can be executed
    # manually with just a few lines of code.
    python -c $'import SimpleHTTPServer;\nSimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map[""] = "text/plain";\nSimpleHTTPServer.test();' "$port"
}


##############################################################################
# Completion
##############################################################################

# Add tab completion for many Bash commands
if which brew > /dev/null && [ -f "$(brew --prefix)/etc/bash_completion" ]; then
    source "$(brew --prefix)/etc/bash_completion";
elif [ -f /etc/bash_completion ]; then
    source /etc/bash_completion;
fi;

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2)" scp sftp ssh

# Grunt
type -P grunt &>/dev/null && eval "$(grunt --completion=bash)"


##############################################################################
# Prompt
##############################################################################

source "${DOTFILES_DIR}/lib/colors"

# import git prompt if not already sourced by bash completiong above
if [ -z $(type -t __git_ps1) ]; then
    if which brew > /dev/null && [ -f "$(brew --prefix)/etc/bash_completion.d/git-prompt.sh" ]; then
        source $(brew --prefix)/etc/bash_completion.d/git-prompt.sh
    elif [ -f /usr/lib/git-core/git-sh-prompt ]; then
        source /usr/lib/git-core/git-sh-prompt
    fi
fi

GIT_PS1_SHOWDIRTYSTATE=true
GIT_PS1_SHOWSTASHSTATE=true
GIT_PS1_SHOWUNTRACKEDFILES=true
GIT_PS1_SHOWUPSTREAM="auto"
GIT_PS1_STATESEPARATOR=" $magenta"

# Tweak standard __git_ps1 output:
# - ensure space before upstream markers and color them
# - remove = upstream marker
# - replace markers
git_info() {
    __git_ps1 "%s" \
    | sed -e "s/\([<>]*\)$/ $yellow\1/" \
    | tr -d "=" \
    | tr "*%<>" "!?⇣⇡"
}

PS1="\[\033]2;\w\007\]"                     # window title to full working directory
PS1+="\[\033]1;\W\007\]"                    # tab title to short working directory
PS1+="\n"                                   # first line (info)
[[ "$SSH_TTY" ]] && PS1+="\[$orange\]\h "   #   only show host if connected via ssh
PS1+="\[$blue\]\w "                         #   working directory
PS1+="$green\$(git_info)"                   #   git branch / status
PS1+="\n"                                   # second line (prompt)
[[ $EUID == 0 ]] && PS1+="\[$red\]\u "      #   only show user if root
PS1+="\[$reset\]\\$ "                       # "smart" prompt char ($ or #)
export PS1
export PS2="→ "




##############################################################################
# Cleanup
##############################################################################
unset path_append path_prepend path_remove

